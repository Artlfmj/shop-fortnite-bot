export declare const VERSION = "__STANZAJS_VERSION__";
export declare const StreamType: {
    readonly Bosh: "http://jabber.org/protocol/httpbind";
    readonly Client: "jabber:client";
    readonly Component: "jabber:component:accept";
    readonly Server: "jabber:server";
};
export declare type StreamType = typeof SASLFailureCondition[keyof typeof SASLFailureCondition];
export declare const SASLFailureCondition: {
    readonly AccountDisabled: "account-disabled";
    readonly CredentialsExpired: "credentials-expired";
    readonly EncryptionRequired: "encryption-required";
    readonly IncorrectEncoding: "incorrect-encoding";
    readonly InvalidAuthzid: "invalid-authzid";
    readonly InvalidMechanism: "invalid-mechanism";
    readonly MalformedRequest: "malformed-request";
    readonly MechanismTooWeak: "mechanism-too-weak";
    readonly NotAuthorized: "not-authorized";
    readonly TemporaryAuthFailure: "temporary-auth-failure";
};
export declare type SASLFailureCondition = typeof SASLFailureCondition[keyof typeof SASLFailureCondition];
export declare const StreamErrorCondition: {
    readonly BadFormat: "bad-format";
    readonly BadNamespacePrefix: "bad-namespace-prefix";
    readonly Conflict: "conflict";
    readonly ConnectionTimeout: "connection-timeout";
    readonly HostGone: "host-gone";
    readonly HostUnknown: "host-unknown";
    readonly ImproperAddressing: "improper-addressing";
    readonly InternalServerError: "internal-server-error";
    readonly InvalidFrom: "invalid-from";
    readonly InvalidId: "invalid-id";
    readonly InvalidNamespace: "invalid-namespace";
    readonly InvalidXML: "invalid-xml";
    readonly NotAuthorized: "not-authorized";
    readonly NotWellFormed: "not-well-formed";
    readonly PolicyViolation: "policy-violation";
    readonly RemoteConnectionFailed: "remote-connection-failed";
    readonly Reset: "reset";
    readonly ResourceConstraint: "resource-constraint";
    readonly RestrictedXML: "restricted-xml";
    readonly SeeOtherHost: "see-other-host";
    readonly SystemShutdown: "system-shutdown";
    readonly UndefinedCondition: "undefined-condition";
    readonly UnsupportedEncoding: "unsupported-encoding";
    readonly UnsupportedStanzaType: "unsupported-stanza-type";
    readonly UnsupportedVersion: "unsupported-version";
};
export declare type StreamErrorCondition = typeof StreamErrorCondition[keyof typeof StreamErrorCondition];
export declare const StanzaErrorCondition: {
    readonly BadRequest: "bad-request";
    readonly Conflict: "conflict";
    readonly FeatureNotImplemented: "feature-not-implemented";
    readonly Forbidden: "forbidden";
    readonly Gone: "gone";
    readonly InternalServerError: "internal-server-error";
    readonly ItemNotFound: "item-not-found";
    readonly JIDMalformed: "jid-malformed";
    readonly NotAcceptable: "not-acceptable";
    readonly NotAllowed: "not-allowed";
    readonly NotAuthorized: "not-authorized";
    readonly PolicyViolation: "policy-violation";
    readonly RecipientUnavailable: "recipient-unavailable";
    readonly Redirect: "redirect";
    readonly RegistrationRequired: "registration-required";
    readonly RemoteServerNotFound: "remote-server-not-found";
    readonly RemoteServerTimeout: "remote-server-timeout";
    readonly ResourceConstraint: "resource-constraint";
    readonly ServiceUnavailable: "service-unavailable";
    readonly SubscriptionRequired: "subscription-required";
    readonly UndefinedCondition: "undefined-condition";
    readonly UnexpectedRequest: "unexpected-request";
};
export declare type StanzaErrorCondition = typeof StanzaErrorCondition[keyof typeof StanzaErrorCondition];
export declare const MessageType: {
    readonly Chat: "chat";
    readonly Error: "error";
    readonly GroupChat: "groupchat";
    readonly Headline: "headline";
    readonly Normal: "normal";
};
export declare type MessageType = typeof MessageType[keyof typeof MessageType];
export declare const PresenceType: {
    readonly Available: undefined;
    readonly Error: "error";
    readonly Probe: "probe";
    readonly Subscribe: "subscribe";
    readonly Subscribed: "subscribed";
    readonly Unavailable: "unavailable";
    readonly Unsubscribe: "unsubscribe";
    readonly Unsubscribed: "unsubscribed";
};
export declare type PresenceType = typeof PresenceType[keyof typeof PresenceType];
export declare const IQType: {
    readonly Error: "error";
    readonly Get: "get";
    readonly Result: "result";
    readonly Set: "set";
};
export declare type IQType = typeof IQType[keyof typeof IQType];
export declare const PresenceShow: {
    readonly Away: "away";
    readonly Chat: "chat";
    readonly DoNotDisturb: "dnd";
    readonly ExtendedAway: "xa";
};
export declare type PresenceShow = typeof PresenceShow[keyof typeof PresenceShow];
export declare const RosterSubscription: {
    readonly Both: "both";
    readonly From: "from";
    readonly None: "none";
    readonly ReceivePresenceOnly: "to";
    readonly Remove: "remove";
    readonly SendAndReceivePresence: "both";
    readonly SendPresenceOnly: "from";
    readonly To: "to";
};
export declare type RosterSubscription = typeof RosterSubscription[keyof typeof RosterSubscription];
export declare const DataFormType: {
    readonly Cancel: "cancel";
    readonly Form: "form";
    readonly Result: "result";
    readonly Submit: "submit";
};
export declare type DataFormType = typeof DataFormType[keyof typeof DataFormType];
export declare const DataFormFieldType: {
    readonly Boolean: "boolean";
    readonly Fixed: "fixed";
    readonly Hidden: "hidden";
    readonly JID: "jid-single";
    readonly JIDMultiple: "jid-multi";
    readonly List: "list-single";
    readonly ListMultiple: "list-multi";
    readonly Password: "text-private";
    readonly Text: "text-single";
    readonly TextMultiple: "text-multi";
    readonly TextPrivate: "text-private";
};
export declare type DataFormFieldType = typeof DataFormFieldType[keyof typeof DataFormFieldType];
export declare const MUCAffiliation: {
    readonly Admin: "admin";
    readonly Banned: "outcast";
    readonly Member: "member";
    readonly None: "none";
    readonly Outcast: "outcast";
    readonly Owner: "owner";
};
export declare type MUCAffiliation = typeof MUCAffiliation[keyof typeof MUCAffiliation];
export declare const MUCRole: {
    readonly Moderator: "moderator";
    readonly None: "none";
    readonly Participant: "participant";
    readonly Visitor: "visitor";
};
export declare type MUCRole = typeof MUCRole[keyof typeof MUCRole];
export declare const MUCStatusCode: {
    readonly AffiliationChanged: "101";
    readonly AffiliationLost: "321";
    readonly Banned: "301";
    readonly Error: "333";
    readonly Kicked: "307";
    readonly LoggingDisabled: "171";
    readonly LoggingEnabled: "170";
    readonly MembershipLost: "322";
    readonly NickChanged: "303";
    readonly NickChangedByService: "210";
    readonly NonAnonymous: "172";
    readonly NonAnonymousRoom: "100";
    readonly NonPrivacyConfigurationChange: "104";
    readonly RoomCreated: "201";
    readonly SelfPresence: "110";
    readonly SemiAnonymous: "173";
    readonly Shutdown: "332";
    readonly UnavailableMembersListed: "102";
    readonly UnavailableMembersNotListed: "103";
};
export declare type MUCStatusCode = typeof MUCStatusCode[keyof typeof MUCStatusCode];
export declare const PubsubErrorCondition: {
    readonly ClosedNode: "closed-node";
    readonly ConfigurationRequired: "configuration-required";
    readonly InvalidJID: "invalid-jid";
    readonly InvalidOptions: "invalid-options";
    readonly InvalidPayload: "invalid-payload";
    readonly InvalidSubscriptionId: "invalid-subid";
    readonly ItemForbidden: "item-forbidden";
    readonly ItemRequired: "item-required";
    readonly JIDRequired: "jid-required";
    readonly MaxItemsExceeded: "max-items-exceeded";
    readonly MaxNodesExceeded: "max-nodes-exceeded";
    readonly NodeIdRequired: "nodeid-required";
    readonly NotInRosterGroup: "not-in-roster-group";
    readonly NotSubscribed: "not-subscribed";
    readonly PayloadRequired: "payload-required";
    readonly PayloadTooBig: "payload-too-big";
    readonly PendingSubscription: "pending-subscription";
    readonly PresenceSubscriptionRequired: "presence-subscription-required";
    readonly SubscriptionIdRequired: "subid-required";
    readonly TooManySubscriptions: "too-many-subscriptions";
    readonly Unsupported: "unsupported";
    readonly UnsupportedAccessModel: "unsupported-access-model";
};
export declare type PubsubErrorCondition = typeof PubsubErrorCondition[keyof typeof PubsubErrorCondition];
export declare const ChatState: {
    readonly Active: "active";
    readonly Composing: "composing";
    readonly Gone: "gone";
    readonly Inactive: "inactive";
    readonly Paused: "paused";
};
export declare type ChatState = typeof ChatState[keyof typeof ChatState];
export declare const JingleSessionRole: {
    readonly Initiator: "initiator";
    readonly Responder: "responder";
};
export declare type JingleSessionRole = typeof JingleSessionRole[keyof typeof JingleSessionRole];
export declare const JingleApplicationDirection: {
    readonly Inactive: "inactive";
    readonly Receive: "recvonly";
    readonly Send: "sendonly";
    readonly SendReceive: "sendrecv";
};
export declare type JingleApplicationDirection = typeof JingleApplicationDirection[keyof typeof JingleApplicationDirection];
export declare const JingleContentSenders: {
    readonly Both: "both";
    readonly Initiator: "initiator";
    readonly None: "none";
    readonly Responder: "responder";
};
export declare type JingleContentSenders = typeof JingleContentSenders[keyof typeof JingleContentSenders];
export declare const JingleAction: {
    readonly ContentAccept: "content-accept";
    readonly ContentAdd: "content-add";
    readonly ContentModify: "content-modify";
    readonly ContentReject: "content-reject";
    readonly ContentRemove: "content-remove";
    readonly DescriptionInfo: "description-info";
    readonly SecurityInfo: "security-info";
    readonly SessionAccept: "session-accept";
    readonly SessionInfo: "session-info";
    readonly SessionInitiate: "session-initiate";
    readonly SessionTerminate: "session-terminate";
    readonly TransportAccept: "transport-accept";
    readonly TransportInfo: "transport-info";
    readonly TransportReject: "transport-reject";
    readonly TransportReplace: "transport-replace";
};
export declare type JingleAction = typeof JingleAction[keyof typeof JingleAction];
export declare const JingleErrorCondition: {
    readonly OutOfOrder: "out-of-order";
    readonly TieBreak: "tie-break";
    readonly UnknownContent: "unknown-content";
    readonly UnknownSession: "unknown-session";
    readonly UnsupportedInfo: "unsupported-info";
};
export declare type JingleErrorCondition = typeof JingleErrorCondition[keyof typeof JingleErrorCondition];
export declare const JingleReasonCondition: {
    readonly AlternativeSession: "alternative-session";
    readonly Busy: "busy";
    readonly Cancel: "cancel";
    readonly ConnectivityError: "connectivity-error";
    readonly Decline: "decline";
    readonly Expired: "expired";
    readonly FailedApplication: "failed-application";
    readonly FailedTransport: "failed-transport";
    readonly GeneralError: "general-error";
    readonly Gone: "gone";
    readonly IncompatibleParameters: "incompatible-parameters";
    readonly MediaError: "media-error";
    readonly SecurityError: "security-error";
    readonly Success: "success";
    readonly Timeout: "timeout";
    readonly UnsupportedApplications: "unsupported-applications";
    readonly UnsupportedTransports: "unsupported-transports";
};
export declare type JingleReasonCondition = typeof JingleReasonCondition[keyof typeof JingleReasonCondition];
export declare const USER_MOODS: string[];
export declare const USER_ACTIVITY_GENERAL: string[];
export declare const USER_ACTIVITY_SPECIFIC: string[];
export declare const JINGLE_INFO: (namespace: string, name: string) => string;
export declare const JINGLE_INFO_MUTE: string;
export declare const JINGLE_INFO_UNMUTE: string;
export declare const JINGLE_INFO_HOLD: string;
export declare const JINGLE_INFO_UNHOLD: string;
export declare const JINGLE_INFO_ACTIVE: string;
export declare const JINGLE_INFO_RINGING: string;
export declare const JINGLE_INFO_CHECKSUM_5: string;
export declare const JINGLE_INFO_RECEIVED_5: string;
export declare function toList<T>(data: {
    [key: string]: T;
}): T[];
export declare function sendersToDirection(role: JingleSessionRole, senders?: JingleContentSenders): JingleApplicationDirection;
export declare function directionToSenders(role: JingleSessionRole, direction?: JingleApplicationDirection): JingleContentSenders;
